<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2616 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml">
<!ENTITY ASCII SYSTEM "http://xml.resource.org/public/rfc/bibxml2/reference.ANSI.X3-4.1986.xml">
<!ENTITY HTML5 SYSTEM "reference.W3C.ED-html5-20070810.xml">
<!ENTITY title "Tolerant HTTP Parsing">
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc ipr="full3978" category="exp">
<front>
	<title>&title;</title>
	<author initials="G.M." surname="Sneddon" fullname="Geoffrey Sneddon" role="editor">
	<!-- I work for no organisation, so no need for this to even be opened. -->
	<organization/>
	<address>
		<postal>
			<street>Toll Park</street>
			<street>20 Hepburn Gardens</street>
			<city>St Andrews</city>
			<region>Fife</region>
			<code>KY16 9DE</code>
			<country>GB</country>
		</postal>
		<phone>+44 7807 360 291</phone>
		<email>geoffers@gmail.com</email>
		<uri>http://geoffers.uni.cc/</uri>
	</address>
	</author>
	<date month="August" year="2007" />
	<area>Applications</area>
	<keyword>I-D</keyword>
	<keyword>Internet-Draft</keyword>
	<keyword>HTTP</keyword>
	<keyword>HyperText Transfer Protocol</keyword>
	<!-- !Abstract -->
	<abstract>
		<t>The HyperText Transfer Protocol (HTTP) has been widely used by the 
		  World Wide Web (WWW) since 1990. This specification attempts to define
		  how to parse HTTP requests and responses according to the current
		  de-facto standards used by user-agents (UAs) at the time
		  of writing.</t>
	</abstract>
</front>
<middle>
	<!-- !Introduction -->
	<section title="Introduction">
		<t>Ever since HTTP's conception, there have never been any defined
		  standards about its parsing in the real world.
		  <xref target="RFC2616"/> tried to improve this situation with a
		  section (19.3) entited "Tolerant Applications", providing advice about
		  parsing requests and responses. However, it did not go into specific
		  details that are needed for interoperability with current
		  (non-conformant) servers. The lack of any current specification
		  defining such specifics makes it hard for any new UA to be created
		  without first spending large amounts of time reverse engineering what
		  is in cases purely bizzare behaviour, which unless you know about
		  beforehand, you may not write enough test cases to find some of the
		  oddest behaviour.</t>
		
		<t>This specification aims to help the above mentioned problem by
		  documenting the behaviour of UAs at the time of writing. As with any
		  data format without specified error handling, this behaviour is likely
		  to change over time.</t>
		
		<!-- !Requirements Language -->
		<section title="Requirements Language">
			<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
			  "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
			  "OPTIONAL" in this document are to be interpreted as described in
			  <xref target="RFC2119"/>.</t>
		</section>
		
		<!-- !Conformance Requirements -->
		<section title="Conformance Requirements">
			<t>This specification is defined in terms of the US-ASCII character
			  set, as defined in <xref target="ANSI.X3-4.1986"/>.</t>
			  
			<t>The conformance requirements of this specification are phrased as
			  algorithms and may be implemented in any manner, so long as the
			  end result is equivalent (in particular, the algorithms defined in
			  this specification are intended to be easy to follow, and not
			  intended to be performant).</t>
			
			<t>User agents may impose implementation-specific limits on
			  otherwise unconstrained inputs, e.g., to prevent denial of service
			  attacks, to guard against running out of memory, or to work around
			  platform-specific limitations.</t>
		</section>
	</section>
	
	<!-- !Parsing -->
	<section title="Parsing">
		<t>Implementations of this specification MUST implement the below state
		  machine, with a single exception: they MAY omit carriage returns (CRs,
		  US-ASCII code 0x0D) from the name and value of headers.</t>
		
		<t>Let position be a pointer to a byte in the input stream, initally
		  pointing at the first byte.</t>
		
		<!-- !Common Subroutines -->
		<section title="Common Subroutines">
			<!-- !Collect Bytes -->
			<section title="Collect Bytes" anchor="collect-bytes">
				<t>When an algorithm requires the parser to "collect bytes", the
				  following algorithm MUST be run, with "bytes" being the set of
				  bytes that can be collected:</t>
				
				<list style="numbers">
					<t>Let "input" and "position" be the same variables as those
					  of the same name in the algorithm that invoked these
					  steps.</t>
					
					<t>Let "result" be an empty string.</t>
					
					<t>While "position" doesn't point past the end of "input"
					  and the byte at position is one of the "bytes", append
					  that byte to the end of "result" and advance "position" to
					  the next byte in "input".</t>
					
					<t>Return "result".</t>
				</list>
			</section>
			
			<!-- !Collect Bytes -->
			<section title="Collect Bytes That Aren't" anchor="collect-bytes-that-arent">
				<t>When an algorithm requires the parser to "collect bytes that
				  aren't", the following algorithm MUST be run, with "bytes"
				  being the set of bytes that cannot be collected:</t>
				
				<list style="numbers">
					<t>Let "input" and "position" be the same variables as those
					  of the same name in the algorithm that invoked these
					  steps.</t>
					
					<t>Let "result" be an empty string.</t>
					
					<t>While "position" doesn't point past the end of "input"
					  and the byte at position is not one of the "bytes", append
					  that byte to the end of "result" and advance "position" to
					  the next byte in "input".</t>
					
					<t>Return "result".</t>
				</list>
			</section>
			
			<!-- !Skip Inline Whitespace -->
			<section title="Skip Inline Whitespace">
				<t>When an algorithm requires the parser to "skip inline
				  whitespace", the parser should <xref target="collect-bytes">
				  collect bytes</xref> that are 0x09 (US-ASCII horizontal tab)
				  or 0x20 (US-ASCII space).</t>
			</section>
			
			<!-- !Is Linear Whitespace -->
			<section title="Is Linear Whitespace">
				<t>If any of the below are true, then return true. Otherwise,
				  return false.</t>
				
				<list style="symbols">
					<t>Position points to 0x09 (US-ASCII horizontal tab), or</t>
					<t>Position points to 0x20 (US-ASCII space), or</t>
					<t>Position points to 0x0A (US-ASCII line feed), and is
					  followed by either 0x09 (US-ASCII horizontal tab) or 0x20
					  (US-ASCII space).</t>
				</list>
			</section>
		</section>
	</section>
</middle>
<back>
	<!-- !Normative References -->
	<references title="Normative References">
		&ASCII;
		&RFC2119;
		&RFC2616;
	</references>
	
	<!-- !Informative References -->
	<references title="Informative References">
		&HTML5;
	</references>
</back>
</rfc>