<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc PUBLIC "-//IETF//DTD RFC 2629//EN"
	"http://xml.resource.org/authoring/rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2616 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml">
<!ENTITY ASCII SYSTEM "http://xml.resource.org/public/rfc/bibxml2/reference.ANSI.X3-4.1986.xml">
<!ENTITY % rfc2629-xhtml PUBLIC "-//IETF//ENTITIES XHTML subset for RFC 2629//EN" "http://xml.resource.org/authoring/rfc2629-xhtml.ent">
<!ENTITY % rfc2629-other PUBLIC "-//IETF//ENTITIES Other for RFC 2629//EN" "http://xml.resource.org/authoring/rfc2629-other.ent">
%rfc2629-xhtml;
%rfc2629-other;
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc comments="yes"?>
<?rfc strict="yes"?>
<?rfc inline="yes"?>
<rfc ipr="full3978" category="info" updates="2616">
<front>
	<title>Tolerant HTTP Parsing</title>
	<author initials="G.M." surname="Sneddon" fullname="Geoffrey Sneddon">
	<!-- I work for no organisation, so no need for this to even be opened. -->
	<organization/>
	<address>
		<postal>
			<street>Toll Park</street>
			<street>20 Hepburn Gardens</street>
			<city>St Andrews</city>
			<region>Fife</region>
			<code>KY16 9DE</code>
			<country>GB</country>
		</postal>
		<phone>+44 7807 360 291</phone>
		<email>geoffers@gmail.com</email>
		<uri>http://geoffers.uni.cc/</uri>
	</address>
	</author>
	<date month="September" year="2007" />
	<area>Applications</area>
	<keyword>I-D</keyword>
	<keyword>Internet-Draft</keyword>
	<keyword>HTTP</keyword>
	<keyword>HyperText Transfer Protocol</keyword>
	<!-- !Abstract -->
	<abstract>
		<t>The HyperText Transfer Protocol (HTTP) has been widely used by the 
		  World Wide Web (WWW) since 1990. This specification updates RFC 2616,
		  defining how to parse HTTP requests and responses in a way that is
		  compatible with user-agents (UAs) and servers at the time of writing.</t>
	</abstract>
	
	<!-- Editorial Note -->
	<note title="Editorial Note">
		<t><cref>Remove this section upon publication.</cref></t>
		
		<t>This is a work in progress, and may change in part, or in whole. Do
		  not take anything in any draft version to be final. Comments are
		  very welcome, and should be sent to
		  <eref target="mailto:geoffers+tolerant@gmail.com">geoffers+tolerant@gmail.com</eref>
		  .</t>
		
		<t>Known issues as of writing:</t>
		
		<t><list style="symbols">
			<t>The majority of the parsing algorithm is yet to be written.</t>
			
			<t><xref target="RFC2616"/> isn't properly referenced.</t>
		</list></t>
	</note>
</front>
<middle>
	<!-- !Introduction -->
	<section title="Introduction">
		<t>Ever since HTTP's conception, there have never been any standards
		  regarding its parsing in the real world. <xref target="RFC2616"/>
		  tried to improve this situation with a section (19.3) entited 
		  "Tolerant Applications", providing advice about parsing requests and
		  responses. However, it did not go into specific details that are
		  needed for interoperability with current (non-conformant) servers. The
		  lack of any current specification defining such specifics makes it
		  hard for any new UA to be created without first spending large amounts
		  of time reverse engineering what is in cases purely bizzare behaviour,
		  which unless you know about beforehand, you may not write enough test
		  cases to find some of the oddest behaviour.</t>
		
		<t>This specification aims to help the above mentioned problem by
		  documenting the behaviour of UAs at the time of writing. As with any
		  data format without specified error handling, this behaviour is likely
		  to change over time.</t>
		
		<!-- !Notational Conventions -->
		<section title="Notational Conventions">
			<t>This specification is defined in terms of the US-ASCII character
			  set, as defined in <xref target="ANSI.X3-4.1986"/>.</t>
			
			<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
			  "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
			  "OPTIONAL" in this document are to be interpreted as described in
			  <xref target="RFC2119"/>.</t>
		</section>
		
		<!-- !Conformance Requirements -->
		<section title="Conformance Requirements">
			<t>The conformance requirements of this specification are phrased as
			  algorithms and may be implemented in any manner, so long as the
			  end result is equivalent (in particular, the algorithms defined in
			  this specification are intended to be easy to follow, and not
			  intended to be performant).</t>
			
			<t>Implementations may impose implementation-specific limits on
			  otherwise unconstrained inputs, e.g., to prevent denial of service
			  attacks, to guard against running out of memory, or to work around
			  platform-specific limitations.</t>
		</section>
	</section>
	
	<!-- !Parsing -->
	<section title="Parsing">
		<!-- !Common Subroutines -->
		<section title="Common Subroutines">
			<!-- !Collect Bytes That Are In The Group -->
			<section title="Collect Bytes That Are In The Group" anchor="collect-bytes-that-are">
				<t>When an algorithm requires the parser to "collect bytes", the
				  following algorithm MUST be run, with "bytes" being the set of
				  bytes that can be collected:</t>
				
				<t><list style="numbers">
					<t>Let "input" and "position" be the same variables as those
					  of the same name in the algorithm that invoked these
					  steps.</t>
					
					<t>Let "result" be an empty string.</t>
					
					<t>While "position" doesn't point past the end of "input"
					  and the byte at position is one of the "bytes", append
					  that byte to the end of "result" and advance "position" to
					  the next byte in "input".</t>
					
					<t>Return "result".</t>
				</list></t>
			</section>
			
			<!-- !Collect Bytes That Aren't In The Group -->
			<section title="Collect Bytes That Aren't In The Group" anchor="collect-bytes-that-arent">
				<t>When an algorithm requires the parser to "collect bytes that
				  aren't", the following algorithm MUST be run, with "bytes"
				  being the set of bytes that cannot be collected:</t>
				
				<t><list style="numbers">
					<t>Let "input" and "position" be the same variables as those
					  of the same name in the algorithm that invoked these
					  steps.</t>
					
					<t>Let "result" be an empty string.</t>
					
					<t>While "position" doesn't point past the end of "input"
					  and the byte at position is not one of the "bytes", append
					  that byte to the end of "result" and advance "position" to
					  the next byte in "input".</t>
					
					<t>Return "result".</t>
				</list></t>
			</section>
			
			<!-- !Skip Inline Whitespace -->
			<section title="Skip Inline Whitespace" anchor="skip-inline-whitespace">
				<t>When an algorithm requires the parser to "skip inline
				  whitespace", the parser MUST <xref target="collect-bytes-that-are">
				  collect bytes that are</xref> either 0x09 (US-ASCII horizontal
				  tab) or 0x20 (US-ASCII space).</t>
			</section>
			
			<!-- !Is Linear Whitespace -->
			<section title="Is Linear Whitespace" anchor="is-linear-whitespace">
				<t>When an algorithm requires the parser to see if the following
				  byte "is linear whitespace", the following algorithm MUST be
				  run:</t>
				
				<t><list style="numbers">
					<t>Let "input" and "position" be the same variables as those
					  of the same name in the algorithm that invoked these
					  steps.</t>
					
					<t>If "position" points to 0x09 (US-ASCII horizontal tab),
					  then return true, otherwise proceed to the next step.</t>
					
					<t>If "position" points to 0x20 (US-ASCII space), then
					  return true, otherwise proceed to the next step.</t>
					
					<t>If "position" points to 0x0D (US-ASCII character return),
					  then return true, otherwise proceed to the next step.</t>
					  
					<t>If "position" points to 0x0A (US-ASCII line feed), and is
					  followed by either 0x09 (US-ASCII horizontal tab) or 0x20
					  (US-ASCII space), then return true, otherwise proceed to
					  the next step.</t>
					
					<t>The next byte is not linear whitespace. Return false.</t>
				</list></t>
			</section>
			
			<!-- !Parse Linear Whitespace -->
			<section title="Parse Linear Whitespace">
				<t>When an algorithm requires the parser to "parse linear
				  whitespace", the following algorithm MUST be run:</t>
				
				<t><list style="numbers">
					<t>Let "input", "position", and "value" be the same
					  variables as those of the same name in the algorithm that
					  invoked these steps.</t>
					
					<t>If the following byte <xref target="is-linear-whitespace">
					  is linear whitespace</xref> then advance "position" to the
					  next byte in "input" before repeating this step.</t>
					
					<t>Append a single 0x20 (US-ASCII space) byte to the end of
					  "value".</t>
				</list></t>
			</section>
		</section>
	</section>
	
	<!-- !Security Considerations -->
	<section title="Security Considerations">
		<t><cref>This section is just a very rough draft.</cref></t>
		
		<t>This specification is just a parsing algorithm, and therefore
		  any risks (excluding implementations issues such as buffer overflows)
		  are inherited from <xref target="RFC2616"/>.</t>
	</section>
	
	<!-- !IANA Considerations -->
	<section title="IANA Considerations">
		<t>This document has no actions for IANA.</t>
	</section>
	
	<!-- !Contributors -->
	<appendix title="Contributors">
		<t>The following people contributed to this document (often by helping
		  to reverse engineer current behaviour, or helping to review this
		  document): Philip Taylor.</t>
	</appendix>
	
	<!-- !Further Suggestions -->
	<appendix title="Further Suggestions">
		<t>This section is informative.</t>
		
		<t>While the scope of this specification is only parsing of HTTP
		  requests and responses, there are several other things that I am aware
		  of that should be pointed out to anyone implementing
		  <xref target="RFC2616"/>:</t>
		
		<t><list style="symbols">
			<t>The Content-Location header SHOULD be ignored. This is due to
			  multiple versions of Microsoft Internet Information Services (IIS)
			  sending incorrect Content-Location headers. Implementing this as
			  required by <xref target="RFC2616"/> will break a significant
			  number of websites.</t>
			
			<t>The Content-Type SHOULD NOT on its own be trusted. Content-Type
			  sniffing as defined in <xref target="HTML 5"/>
			  SHOULD be used to determine the true type of the resource. This
			  is due to a large number of websites sending incorrect
			  Content-Type headers, often because the maintainer of the website
			  cannot change the header, or because the file extension/MIME type
			  database is outdated.</t>
		</list></t>
	</appendix>
</middle>
<back>
	<!-- !Normative References -->
	<references title="Normative References">
		&ASCII;
		&RFC2119;
		&RFC2616;
	</references>
	
	<!-- !Informative References -->
	<references title="Informative References">
		<reference anchor="HTML 5"  target="http://dev.w3.org/cvsweb/~checkout~/html5/spec/Overview.html?rev=1.198">
			<front>
				<title>HTML 5</title>
				<author initials="I." surname="Hickson" fullname="Ian Hickson" role="editor">
					<organization>Google, Inc.</organization>
					<address>
						<email>ian@hixie.ch</email>
					</address>
				</author>
				<author initials="D." surname="Hyatt" fullname="David Hyatt" role="editor">
					<organization>Apple, Inc.</organization>
				</author>
				<date month="August" day="10" year="2007"/>
			</front>
			<seriesInfo name="World Wide Web Consortium ED" value="ED-html5-20070810"/>
			<format type="HTML" target="http://dev.w3.org/cvsweb/~checkout~/html5/spec/Overview.html?rev=1.198"/>
		</reference>
	</references>
</back>
</rfc>